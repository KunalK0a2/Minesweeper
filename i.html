<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minesweeper Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f7f7f7;
    }
    h1 {
      margin-bottom: 20px;
    }
    .board {
      display: grid;
      gap: 2px;
      background-color: #333;
      padding: 5px;
    }
    .cell {
      width: 40px;
      height: 40px;
      background-color: #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      cursor: pointer;
      border: 1px solid #999;
    }
    .cell.revealed {
      background-color: #eee;
      cursor: default;
    }
    .cell.mine {
      background-color: crimson;
      color: white;
    }
    .cell.flag {
      background-color: orange;
      color: #333;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Minesweeper Game</h1>
  <button onclick="resetGame()">Restart Game</button>
  <div id="game"></div>

  <script>
   const boardSize = 10;
    const mineCount = 15;
    let board, cells, mines;
    //const audio = new Audio('bomb.wav');
    const initializeGame = () => {

      // Resets the board
      document.getElementById('game').innerHTML = '';
      board = document.createElement('div');
      board.className = 'board';
      board.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;

      cells = [];
      mines = [];

      // Creates all the cells
      for (let i = 0; i < boardSize * boardSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.revealed = false;
        board.appendChild(cell);
        cells.push(cell);
      }

      // Place mines randomly
      while (mines.length < mineCount) {
        const x = Math.floor(Math.random() * boardSize);
        const y = Math.floor(Math.random() * boardSize);
        const cell = getCell(x, y);

        if (!cell.dataset.mine) {
          cell.dataset.mine = true;
          mines.push(cell);
        }
      }

      // Calculate adjacent mines
      cells.forEach((cell, index) => {
        const x = index % boardSize;
        const y = Math.floor(index / boardSize);

        if (cell.dataset.mine) return;

        let mineCount = 0;
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (isValidCell(x + dx, y + dy)) {
              const neighbor = getCell(x + dx, y + dy);
              if (neighbor.dataset.mine) mineCount++;
            }
          }
        }
        cell.dataset.mineCount = mineCount;
      });

      // Clicking Evenet Listener
      cells.forEach((cell) => {
        cell.addEventListener('click', () => revealCell(cell));
        cell.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          if (cell.dataset.revealed === 'true') return;

          if (cell.classList.contains('flag')) {
            cell.classList.remove('flag');
            cell.textContent = '';
          } else {
            cell.classList.add('flag');
            cell.textContent = 'ðŸš©';

          }
        });
      });
      document.getElementById('game').appendChild(board);
    };

    const getCell = (x, y) => cells[y * boardSize + x];
    const isValidCell = (x, y) => x >= 0 && x < boardSize && y >= 0 && y < boardSize;

    //Reveals the cell on clicking
    const revealCell = (cell) => {
      if (cell.dataset.revealed === 'true') return;

      cell.dataset.revealed = true;
      cell.classList.add('revealed');

      if (cell.dataset.mine) {
        cell.classList.add('mine');
        cell.textContent = 'ðŸ’£';
        //audio.play();
        alert('Game Over!');
        return;
      }

      const mineCount = cell.dataset.mineCount;
      if (mineCount > 0) {
        cell.textContent = mineCount;
        return;
      }

      // Logic for revealing neighbours
      const index = cells.indexOf(cell);
      const x = index % boardSize;
      const y = Math.floor(index / boardSize);

      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (isValidCell(x + dx, y + dy)) {
            revealCell(getCell(x + dx, y + dy));
          }
        }
      }
    };

    // Reset button logic
    const resetGame = () => {
      initializeGame();
    };

    initializeGame();
  </script>
</body>
</html>
